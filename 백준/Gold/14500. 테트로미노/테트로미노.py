n,m=map(int,(input().split()))

board=[]


blocks=[
     # 하늘색 * 2
    ((0,0),(0,1),(0,2),(0,3)),
    ((0,0),(1,0),(2,0),(3,0)),
    # 노란색 1가지
    ((0,0),(0,1),(1,0),(1,1)), 
     # 주황 회전 4가지
    ((0,0),(1,0),(2,0),(2,1)),
    ((0,0),(0,-1),(0,-2),(1,-2)),
    ((0,0),(-1,0),(-2,0),(-2,-1)),
    ((0,0),(0,1),(0,2),(-1,2)),
    # 주황 대칭 이후 회전 4가지
    ((0,0),(1,0),(2,0),(2,-1)),
    ((0,0),(0,-1),(0,-2),(-1,-2)),
    ((0,0),(-1,0),(-2,0),(-2,1)),
    ((0,0),(0,1),(0,2),(1,2)),
     # 초록 * 4
    ((0,0),(1,0),(1,1),(2,1)),
    ((0,0),(0,-1),(1,-1),(1,-2)), 
    ((0,0),(1,0),(1,-1),(2,-1)),
    ((0,0),(0,-1),(-1,-1),(-1,-2)),
    # 분홍 * 4
    ((0,0),(0,-1),(0,1),(1,0)),
    ((0,0),(0,-1),(0,1),(-1,0)),
    ((0,0),(1,0),(-1,0),(0,-1)),
    ((0,0),(1,0),(-1,0),(0,1)), 
]


for i in range(n):
    board.append(list(map(int,input().split())))

ans=0


for i in range(n):
    for j in range(m):
        for block in blocks:
            curr_score = 0
            for k,cell in enumerate(block):
                pos_r=cell[0]+i
                pos_c=cell[1]+j
                
                # 범위 이내인 경우
                if 0<=pos_r<n and 0<=pos_c<m:
                    # 현재 블럭 위치의 점수를 더함
                    curr_score+=board[pos_r][pos_c]
                    # 마지막 블럭이면서 나온 점수가 더 큰 경우
                    if k==3 and ans < curr_score:
                        ans=curr_score
                        
                # 범위 밖인 경우 다음 블럭으로 넘어감 
                else:
                    break
        
print(ans)